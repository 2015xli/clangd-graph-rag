# Algorithm Summary: `clangd_call_graph_builder.py`

## 1. Overview

This script constructs a function call graph from C/C++ source code by intelligently combining data from two different tools: a `clangd` index file and a `tree-sitter` span file. Its final output is a Cypher script to build this call graph in a Neo4j database.

The core challenge this script solves is that `clangd`'s index identifies function call sites but doesn't link them to their parent "caller" function, while `tree-sitter` can identify the function bodies but doesn't understand `clangd`'s symbol IDs. This script acts as the bridge between the two, matching call sites to the functions that contain them.

## 2. Inputs and Output

-   **Input 1**: A `clangd` index YAML file (e.g., `index.yaml`), which contains all symbol definitions, locations, and references.
-   **Input 2**: A function spans YAML file generated by `tree_sitter_span_extractor.py`, which provides the exact body location for each function.
-   **Output**: A Cypher script (`.cql`) containing `MERGE` and `CREATE` statements to build the graph in Neo4j.

## 3. Algorithm Steps

The process is executed in four main stages:

### Step 1: Data Parsing

The script parses the two YAML input files into structured in-memory objects (`Symbol` and `FunctionSpan` dataclasses).

1.  **Clangd Index**: It parses `!Symbol` and `!References` documents, building a complete map of all functions, their unique IDs (USRs), definition locations, and a list of every location where they are referenced.
2.  **Function Spans**: It parses the `!Span` documents from the `tree-sitter` output to create a simple list of functions, each with the location of its name and, crucially, its body.

### Step 2: Matching Spans to Functions (The Bridge)

This is the most critical step, where the two disparate data sources are unified. The goal is to add the `BodyLocation` from the `tree-sitter` data to the corresponding function `Symbol` from the `clangd` data.

-   **Matching Strategy**: The script matches a `clangd` function to a `tree-sitter` span by creating a composite key for each: `(function_name, file_uri, name_start_line, name_start_column)`. When the key from a `clangd` function's definition matches a key from a `tree-sitter` span, the script considers them the same function and copies the `BodyLocation` into the `clangd` `Symbol` object.

### Step 3: Extracting Call Relationships

With the function symbols now enriched with body locations, the script can determine the caller for each function call.

1.  The script iterates through every symbol from the `clangd` data, treating each as a potential **callee**.
2.  For each callee, it iterates through its list of references and filters them.
3.  **Filtering Call Sites**: It keeps only references with `Kind: 12`. According to the `clangd` specification, this value is a bitmask of `Reference (4)` and `Spelled (8)`, which identifies a true function call site where the function's name is explicitly written in the code.
4.  **Finding the Caller**: For each true call site, the script then searches through all functions that have a `BodyLocation` (the potential **callers**).
5.  Using an inclusion check (`_is_location_within_function_body`), it finds which caller's body contains the call site's location.
6.  When a match is found, a `(caller, callee)` relationship is recorded, and the search for that call site stops.

### Step 4: Generating Cypher Output

The final step translates the discovered relationships into a script for Neo4j.

1.  It generates `MERGE` statements to ensure each function exists as a unique `:Function` node in the graph.
2.  It then iterates through the collected `(caller, callee)` pairs and generates `CREATE` statements to establish a `[:CALLS]` relationship between the corresponding nodes.
