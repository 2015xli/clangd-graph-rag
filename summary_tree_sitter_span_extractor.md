# Algorithm Summary: `tree_sitter_span_extractor.py`

## 1. Overview

This script is a command-line utility designed to parse C/C++ source files (`.c`, `.h`) and extract the precise source code locations (spans) of function definitions. It identifies both the function's name and its body, outputting this information in either YAML or Python dictionary format.

The primary goal is to create structured data that maps function names to their physical locations. Specifically, this script serves as a **critical pre-processing step for the `clangd_call_graph_builder.py` tool**. It provides the essential `BodyLocation` data for each function, which is missing from the `clangd` index file. This allows the call graph builder to accurately determine which function (the caller) contains a specific function call.

The YAML output (`--- !Span`) contains three key fields used for matching and analysis by the downstream script:
- **`Name`**: The name of the function.
- **`NameLocation`**: The precise location of the function's name, used for matching against `clangd`'s definition data.
- **`BodyLocation`**: The precise location of the function's body, used for containment checks to find call sites.

## 2. Core Technology

The script is built upon the **`tree-sitter`** parsing framework.

- **Parser Initialization**: It uses `tree-sitter-c` to get the C language grammar. A `Parser` instance is configured with this grammar to build a concrete syntax tree from the source code.

- **AST Traversal**: The core of the algorithm involves traversing the Abstract Syntax Tree (AST) generated by `tree-sitter`. This allows the script to reliably identify language constructs like function definitions based on the C grammar, making it robust against formatting variations.

## 3. Key Components

### `SpanExtractor` Class

This class encapsulates all the logic for parsing files and extracting function spans.

#### `_extract_functions(tree, source_lines, file_uri)`

This is the main workhorse method that performs the extraction.

1.  **AST Traversal**: It performs a depth-first traversal of the AST, starting from the root node. It uses a stack to manage nodes to visit.
2.  **Node Identification**: During traversal, it inspects each node's `type`. It specifically looks for nodes of type `"function_definition"`.
3.  **Declarator and Identifier Search**:
    *   Once a `function_definition` node is found, it retrieves the child node representing the function's declarator (which contains the type, name, and parameters).
    *   It then calls the `_find_identifier` helper method to recursively search within the declarator subtree for the node of type `"identifier"`. This identifier node corresponds to the function's name.
4.  **Location Extraction & Data Structuring**:
    *   Using the start and end points (`start_point`, `end_point`) of the identifier and body nodes, it records the line/column numbers for both the function's name (`NameLocation`) and its body (`BodyLocation`).
    *   The `FileURI` is added to provide the absolute path context for each location.
    *   The final data for a function is aggregated into a dictionary with the keys `Name`, `Kind`, `NameLocation`, and `BodyLocation`.
5.  **Data Aggregation**: The dictionary is added to a list of all functions found in the file.

#### `get_function_spans(file_path, format)`

This method orchestrates the process for a single file.

1.  It reads the source code from the given `file_path`.
2.  It invokes the `tree-sitter` parser to generate the AST.
3.  It calls `_extract_functions` to get the list of function span dictionaries.
4.  Based on the `format` argument (`"yaml"` or `"dict"`), it either returns the raw list of dictionaries or formats it into a YAML string. The YAML output for each function is prefixed with a `--- !Span` document separator.

#### Helper Methods

-   `get_function_spans_from_files(file_list, format)`: A convenience wrapper to run the extraction on a list of files.
-   `get_function_spans_from_folder(folder, format)`: Recursively walks a directory, finds all `.c` and `.h` files, and runs the extraction on them.

## 4. Command-Line Interface (CLI)

The script is executable and provides a CLI for ease of use.

-   **Entry Point**: The `if __name__ == "__main__":` block handles CLI argument parsing.
-   **Arguments**:
    -   `paths`: One or more required arguments specifying the input source files or folders to process.
    -   `--format`: An optional argument to choose the output format (`yaml` or `dict`). Defaults to `yaml`.
    -   `--output`: An optional argument to specify a file to write the output to. If omitted, the output is printed to standard output.
-   **Execution Flow**: The CLI logic instantiates `SpanExtractor`, processes each path provided (whether it's a file or directory), aggregates the results in the desired format, and then prints to the console or writes to the specified output file.

## 5. Dependencies

-   `pyyaml`: For serializing the output into YAML format.
-   `tree-sitter`: The core parsing framework.
-   `tree-sitter-c`: The C language grammar for `tree-sitter`.
