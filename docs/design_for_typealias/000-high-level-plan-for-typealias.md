# High-Level Plan for TypeAlias Integration

**C/C++ types** C/C++ has basically two groups of data types: user-defined and non-user-defined. 
*   **Non-user-defined types**
    This includes **fundamental types** (sometimes called primitive types) like `int`, `float`, etc., and **derived types** like arrays, pointers, references, and function types.
*   **User-defined types**
    This includes **classes**, **structs**, **unions**, **enums**, and **type aliases** (using `typedef` and `using` keywords), and their **derived types**.

We have already implemented some support for **user-defined types** (`CLASS_STRUCTURE` and `DATA_STRUCTURE`) except for **type aliases**, which is important to understand the underlying types of variables and parameters that use aliases. This document outlines the high-level implementation plan for integrating C/C++ `TypeAlias` symbols (from `typedef` and `using` statements) into the code graph.


### Objective

To enrich the code graph with type alias information, enabling an AI agent to understand the underlying types of variables and parameters that use aliases. This involves identifying aliases, resolving what they point to, and representing this information as new nodes and relationships in Neo4j.

---

### High-Level Plan for Type Alias Integration

This plan incorporates the latest feedback and focuses on the "what" and "why" before we move to implementation.

**1. On Scoping and Discoverability**

*    1.1. We will only create `:TYPE_ALIAS` nodes for aliases defined at the global, namespace, and class/struct scopes. Function-local aliases will be ignored, since they are not accessible from outside of the function, while other kinds of aliases can be accessed with scope prefix.
    
*    1.2.  Every `:TYPE_ALIAS` node will have a `qualified_name` property (e.g., `my_namespace::MyClass::MyAlias`). This will be the primary lookup key for an agent. The node will also have a `name` property and `scope` property (e.g., `MyAlias` and `my_namespace::MyClass`). The `qualified_name` property is unique in the graph. It's `kind` property will be "TypeAlias". 
    *   **Implementation Detail:** The synthetic ID for these nodes is generated as `hash(kind + name + file_uri + name_location)`. Including the `kind` is critical to prevent ID collisions when different entities (e.g., a Struct and its TypeAlias) are generated at the same source location by a macro.

*    1.3.  The relationship from a scope to an alias will be `[:DEFINES_TYPE_ALIAS]`. The scope can be a `:NAMESPACE`, `:CLASS_STRUCTURE`, or `:DATA_STRUCTURE`. An agent can query `MATCH (scope)-[:DEFINES_TYPE_ALIAS]->(alias:TYPE_ALIAS)` to find where an alias is defined. They can also use `MATCH (alias:TYPE_ALIAS) WHERE alias.qualified_name ENDS WITH 'my_namespace::MyClass::MyAlias' OR alias.name = 'MyAlias'` to find an alias.

*    1.4. A `:TYPE_ALIAS` node can also be found from its defining `:FILE` node, using `MATCH (file:FILE)-[:DEFINES]->(alias:TYPE_ALIAS)`. This is because the `:FILE` node has a `[:DEFINES]` relationship to all the symbols defined in the file, including `:TYPE_ALIAS` nodes.

*    1.5. The `:TYPE_ALIAS` node will have `name_location` and `body_location` properties. The `body_location` property will store the location of the full alias definition, not just the body part. This is especially important for the templated type alias definition like `template <typename T> using MyVector = std::vector<T>;`. 

*    1.6. The `:TYPE_ALIAS` nodes are also `:DEFINES`-ed by the `:FILE` node that matches its `file_path` property. 

*    1.7. **Macro-Generated Aliases:** If a type alias is generated by a macro (detected via AST expansion tracking), the node will include an `original_name` property containing the macro invocation text and an `[:EXPANDED_FROM]` relationship to the corresponding `:MACRO` node. This provides the agent with the necessary causality to understand "magic" type names.

**2. Representation of the aliased type (aliasee) of a TypeAlias (aliaser)**

*    2.1.  The aliased type of a `:TYPE_ALIAS` node will be represented by an **optional** `[:ALIAS_OF]` relationship to the type definition. This relationship will only be created if the aliased type is a `:CLASS_STRUCTURE`, `:DATA_STRUCTURE`, or another `:TYPE_ALIAS` node that exists within the graph. 

*    2.2.  Mostly the AI agent will rely on the `body_location` property of the `:TYPE_ALIAS` node to retrieve and interpret the source code definition of the alias. It won't rely on [:ALIAS_OF] to retrieve the aliasee info. 
    *   **Rationale:** This simplifies the graph schema and avoids creating a `:TYPE_DEFINITION` (or `:TYPE_EXPRESSION`) node for alisees whose nodes are not in the graph, such as for the fundamental types, template-dependent types, etc. The agent's ability to read and interpret source code is leveraged as the primary mechanism for understanding complex or external aliased types. We are not supposed to create a complete C/C++ typing graph.

*    2.3.  For alias chains (e.g., `using MyInt = int; using MyInt2 = MyInt;`), the `[:ALIAS_OF]` relationship can point to another `:TYPE_ALIAS` node, if our compilation parser knows the right-hand-side aliasee is a type aliaser as well.

*    2.4. When the agent needs to understand the type of a variable that is defined using a type alias, it follows this workflow:
    *   First, it queries for the `TYPE_ALIAS` node (e.g., `MATCH (ta:TYPE_ALIAS) WHERE ta.name = 'type_alias_name' return n.id`).
    *   Then it retrieves the source code the type alias definition from the `path` and `body_location` properties of the node. This is usually provided by an MCP api. It can read the source code to see if it can understand the alias definition. 
    *   If the alias definition includes other unknown type names (e.g., other type aliases or user-defined types), the agent can recursively query for those `(:TYPE_ALIAS)` or `(:CLASS_STRUCTURE|DATA_STRUCTURE)` nodes. (Of course it can query for `:ENTITY` as general label as well.)
    *   Optionally, if the `:TYPE_ALIAS` has `kind` property that is `struct` or `class`, it can attempt to follow the `[:ALIAS_OF]` relationship: `MATCH (ta)-[:ALIAS_OF]->(aliasee:CLASS_STRUCTURE|DATA_STRUCTURE)` to get the aliasee node, and read its `summary` to understand what the user-defined type does.
    *   **Rationale:** This workflow provides a robust mechanism. The reliable approach is source code interpretation, which is available for all other cases, leveraging the agent's inherent capabilities. Graph travesal to the aliased type node is optional.

**3. On Typing Relationships and Their Scope** 

*   NOTE: This section is not implemented yet. More accurately, We decide not to implement it for now. I keep this section only as a record so that I can recall why I haven't implemented it.

*   3.1.  The relationship will be named `[:OF_TYPE]`. The direction will be `(var)-[:OF_TYPE]->(type)`.

*   3.2.  The target of an `[:OF_TYPE]` relationship can be a `:TYPE_ALIAS`, `:CLASS_STRUCTURE`, or `:DATA_STRUCTURE` node.

*   3.3.  We will create `[:OF_TYPE]` relationships for global/namespace `VARIABLE` nodes and for `FIELD` nodes within structs/classes, only if their type is of user-defined types (i.e., `Class`, `Struct`, `Enum`, `Union`, or a type alias). 

*   3.4.  For variables/fields of non-user-defined types (int, char, etc.), we will not create `[:OF_TYPE]` relationships for them. There are two reasons:
         
    *   3.4.1. The fundamental type's string will be stored on the `:VARIABLE` or `:FIELD` node's existing `type` property, which is sufficient for an agent's analysis of simple types. Creating relationships for primitive types would clutter the graph and provide no additional value.
    *   3.4.2. More fundamentally, we skip other types (fundamental types and derived types based on fundamental types) for now because our target is to support agent to understand the type names met in source code. We are not developing a compiler infrastructure. The key difference is, agent can read source code, and understand it. For example, if a type name appearing in a function code is defined in another file, the agent cannot understand it by only reading the function's source code. In this case, the graph is handy for the agent to query for the specific type. On the other hand, the fundamental types (int, char, etc.) and derived types based on fundamental types are defined locally in the source code and are already well-understood by the agent reading the source code. 

*   3.5. For the derived types built upon type aliases such as `MyClass*`, they are derived types of user-defined types. We may not create `[:OF_TYPE]` relationships for them. 
    *  3.5.1. The derived types can be very complex. To create a special kind of node for the derived type expression can be an interesting idea, but does not help too much unless we actually build the typing dependence hierarchy from the derived type nodes to their dependent type nodes. Otherwise, the agent will still need to query the graph for the unknown type names (`MyClass`) in the derived type expression. But building a typing dependence hierarchy is overkill for our graphRAG system, as that is virtually replicating the compiler infrastructure for typing. It is no more efficient for an agent to query through the typing hierarchy than to just query for the unknown type names.

    3.6. Overall, as long as we build nodes for all the type alias names. The agent can query for the names directly. The `[:OF_TYPE]` relationships do not reveal much more information. This is my current understanding. I will come back to revisit this idea if I see some counterexamples.

**3. On External and Anonymous Types**

*   3.1.  **External Aliases:** For now, we will explicitly ignore aliases from headers outside the project path (like `<fstream>`). The existing project-only filtering will be maintained. The reason is, if a developer uses an alias from an external header, the developer is expected to understand the alias's meaning. So does the agent. If in the future we need to support external aliases, we need to build a mechanism to track the external aliases and their meanings.
*    3.2.  **Anonymous Type Structure Aliases:** For a case like `typedef struct {...} aType;` (or `typedef class {...} aType;`, etc.), the anonymous structure will have a synthetic `:DATA_STRUCTURE|CLASS_STRUCTURE` node representing it. The project has already implemented this synthetic node generation. 
         *   **Collision Prevention:** Because the anonymous struct and the `typedef` (TypeAlias) often share the same source location, they would collide if identified only by location. By using **kind-aware synthetic IDs** (`hash(kind + name + location)`), we ensure they are distinct nodes. 
         *   **Linking:** The `:TYPE_ALIAS` node for `aType` will then have an `[:ALIAS_OF]` relationship pointing to the distinct synthetic structure node. (As mentioned previously, even if without the synthetic node, the agent can always retrieve the alias definition source code from the `:TYPE_ALIAS` node.)


**Notes**
*   In the following design documents, we will intentionally decouple the type alias processing from the variable/field processing to make the design modular. That is, we will not touch anything related to Field/Variables before we are completely done with TypeAlias whole processing (stage 010,020,030). More importantly, we will only decide whether to process Field/Variables at all after we are done with TypeAlias whole processing. 