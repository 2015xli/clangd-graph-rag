# High-Level Plan for Macro Integration (Agent-Oriented)

C/C++ macros are "ghosts" in the codebaseâ€”they exist in the source but vanish after preprocessing. For an AI agent, they are often the cause of "magic symbols" (symbols that appear in code but have no obvious definition). This document outlines the design for integrating macro information into the code graph to solve the identity causality problem.

### Objective
To enable coding agents to:
1.  **Resolve "Magic Symbols"**: Understand how symbols are generated via token-pasting (`##`) or DSL-style macros.
2.  **Inspect Definitions**: Read the ground-truth definition of a macro as written by a human.
3.  **Explain Boilerplate**: Understand the intent behind repetitive macro usages.

---

### Guiding Principles

*   **Agent-Centric Causality**: Only capture relationships that help answer "Where did this symbol come from?"
*   **Symbol-Level Abstraction**: Model macros as semantic entities, not just textual trivia.
*   **Top-Level Expansion Only**: To avoid graph explosion, only link generated symbols to the macro actually written at the expansion site, not internal preprocessor dependencies.
*   **Truthful Representation**: Macros are textual transformers. We store their full source definition rather than trying to model their internal substitutions as graph nodes.

---

### 1. The MACRO Node (Foundational Truth)
Every `#define` within the project path is represented as a node.

*   **Labels**: `:MACRO`
*   **Key Properties**:
    *   **`id`**: Synthetic ID. Generated from `hash(kind + name + file_uri + name_location)`. Including the `kind` prevents collisions when different entity types (e.g., a Struct and a TypeAlias) are generated by the same macro at the same location.
    *   **`name`**: The macro identifier.
    *   **`macro_definition`**: The full textual definition of the macro (e.g., `#define MAX(a,b) ((a)>(b)?(a):(b))`). This allows agents to interpret simple macros without reading the source file.
    *   **`body_location`**: The full span of the `#define` directive in the file.
    *   **`is_function_like`**: Boolean (distinguishes `#define X 1` from `#define X(y) ...`).
*   **Relationship**: `(FILE)-[:DEFINES]->(MACRO)`

---

### 2. Symbol Causality (Expansion Context)
Symbols generated or transformed by macros carry extra metadata to explain their origin.

#### 2.1 The `original_name` Property
Any symbol node (Function, Class, etc.) that owes its existence to a macro expansion will have an `original_name` property.
*   **Value**: The exact source text of the macro invocation (e.g., `DECLARE_MODULE(FileSystem, 1)`).
*   **Purpose**: Provides immediate lexical evidence to the agent about how the final symbol name was derived.

#### 2.2 The `[:EXPANDED_FROM]` Relationship
A causal link from the generated symbol to the macro definition.
*   **Relationship**: `(SYMBOL)-[:EXPANDED_FROM]->(MACRO)`
*   **Scope**: Only created for symbols whose **identity** (name/existence) is determined by the macro. This is detected by checking if the symbol's definition range is enclosed by a macro instantiation.
*   **Rule**: We only link **definitions**. References appearing inside a macro (e.g., `std::vector` inside a generator) are not marked as `EXPANDED_FROM`.

---

### 3. Agent Workflow
When an agent encounters an unknown symbol or a DSL-like macro invocation:
1.  **Query by Name**: `MATCH (n:ENTITY) WHERE n.name = 'unknown_symbol' RETURN n`.
2.  **Inspect Causality**: If the node has an `[:EXPANDED_FROM]` edge, the agent follows it to the `MACRO` node.
3.  **Read Definition**: The agent checks the `macro_definition` property for a quick look or uses `get_source_code_by_id` on the `MACRO` node for the full context.
4.  **Interpret Arguments**: The agent looks at the `original_name` on the symbol to see what arguments were passed to the macro at that specific expansion site.

---

### Implementation Infrastructure
1.  **Strict File Matching**: Use trailing separators in project paths to avoid prefix collisions.
2.  **Robust Containment**: Use full `extent` (line and column) comparisons to determine if a symbol is truly inside a macro expansion.
3.  **Collision Prevention**: Synthetic IDs are kind-aware (`kind::name::file:line:col`) to ensure distinct nodes for coincident anonymous structures and type aliases.
