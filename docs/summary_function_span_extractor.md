# Algorithm Summary: `function_span_extractor.py` - Configurable Span Extraction

## 1. Role in the Pipeline

This script is a low-level library module that serves as the primary interface for extracting precise function definition spans from C source code. It is now highly configurable, allowing the user to choose between two distinct parsing strategies:

*   **`treesitter`**: A fast, syntax-only parser that operates directly on source file text.
*   **`clang`**: A slower, but semantically accurate parser that leverages `libclang` and a `compile_commands.json` database.

This module provides the ground-truth physical location of code constructs, which is then used by the `FunctionSpanProvider` to link `clangd` symbols to their source code.

## 2. Core Design: The Strategy Pattern

The module is designed using the Strategy pattern to allow flexible switching between parsing implementations. It consists of:

*   **`BaseExtractorStrategy`**: An abstract base class defining the common interface for all extraction strategies.
*   **`TreeSitterStrategy`**: A concrete implementation using the `tree-sitter` library.
*   **`ClangExtractorStrategy`**: A concrete implementation using `clang.cindex`.
*   **`SpanExtractor` (Context)**: The main class that holds a reference to a strategy object and delegates the actual parsing work to it. It also handles caching.

## 3. `TreeSitterStrategy`

This strategy leverages `tree-sitter-c` for fast, syntax-based parsing.

*   **Algorithm**: It builds a Concrete Syntax Tree (CST) for each source file and traverses it to find `function_definition` nodes. It then extracts the name and body spans directly from the CST.
*   **Pros**:
    *   **Speed**: Extremely fast parsing, as it doesn't perform semantic analysis.
    *   **Simplicity**: Operates directly on source files; no `compile_commands.json` or complex build system integration is required.
    *   **Precision**: Excellent for extracting exact source code spans.
*   **Cons**:
    *   **No Semantic Understanding**: Does not resolve macros or understand types. Functions defined via complex macros may be missed or incorrectly parsed.
    *   **File-by-File**: Processes each file in isolation, without knowledge of `#include` directives.

## 4. `ClangExtractorStrategy`

This strategy leverages `libclang` (via `clang.cindex`) for semantically accurate parsing.

*   **Algorithm**: It uses a `compile_commands.json` database to parse C source files as full Translation Units (TUs). It then traverses the resulting Abstract Syntax Tree (AST) to find `FUNCTION_DECL` cursors that are also definitions.
*   **Key Features**:
    *   **Semantic Accuracy**: Understands macros, includes, and types, providing a compiler's view of the code.
    *   **Robust Macro Handling**: Can correctly identify functions even if their signatures are generated by complex macros.
    *   **Correct File Attribution**: Accurately reports the original source file (`.c` or `.h`) where a function is defined, even if it's part of an included header.
    *   **Dynamic Include Paths**: Automatically discovers `clang`'s internal include paths using `clang -print-resource-dir`.
*   **De-duplication for Header Functions (Memory Optimization)**:
    *   **Problem**: Functions defined in header files (`.h`) can be included and thus processed multiple times if those headers are included by several `.c` files.
    *   **Solution**: The strategy maintains a `self.processed_header_functions` set. When `_walk_ast` encounters a function defined in a header file, it checks this set. If the function has already been processed, it's skipped, preventing redundant data creation and ensuring each header function is reported only once.
*   **Cons**:
    *   **Requires `compile_commands.json`**: Needs a compilation database to correctly parse files with their full build context.
    *   **Slower**: Semantic parsing is inherently more complex and slower than syntax-only parsing.

## 5. Main `SpanExtractor` Class (Context)

This class is the public interface of the module. It handles strategy selection, caching, and delegates the actual extraction work.

*   **Strategy Selection**: Its `__init__` method takes an `extractor_type` argument (`'clang'` or `'treesitter'`) and instantiates the appropriate strategy object.
*   **Caching (`extract_from_folder`)**: The `extract_from_folder` method uses the `SpanCache` to store and retrieve parsed spans for a full project folder. It checks cache validity using Git commit hashes or file modification times.
*   **Non-Caching (`extract_from_files`)**: The `extract_from_files` method processes a specific list of files without using the cache. This is ideal for incremental updates where only a small subset of files needs re-parsing.

## 6. Output Format

Both strategies produce a standardized output: a list of dictionaries, where each dictionary represents a single source file and contains the file's URI and a list of all `FunctionSpan` objects found within it. This consistent format simplifies downstream processing by the `FunctionSpanProvider`.