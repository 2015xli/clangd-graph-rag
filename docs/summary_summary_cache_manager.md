# SummaryCacheManager: Design and Architecture

## 1. High-Level Role

The `SummaryCacheManager` is the dedicated **data layer** for the entire RAG generation process. It is the single source of truth for all cached summary data and is responsible for its persistence to and from disk. Its design ensures that the complex logic of caching is completely abstracted away from the summarization and orchestration layers. It knows nothing about LLMs, Neo4j, or prompt engineering; its only concern is managing the cache data structures and their persistence.

## 2. Core Responsibilities

1.  **Data Management**: Manages the in-memory cache for all summary-related data (`code_analysis`, final `summary`, and `code_hash`).
2.  **State Tracking**: Manages a separate, runtime-only dictionary to track the status of each node *during the current run* (e.g., was it visited? was its summary regenerated?).
3.  **Robust Persistence**: Handles loading the cache from disk at the start of a run and implementing a safe, multi-stage save process at the end.
4.  **Cache Integrity**: Implements logic to ensure the cache remains healthy and complete, including pruning, self-healing, and a safe promotion process for new cache files.
5.  **CLI Functionality**: Provides a command-line interface for manual backup and restore operations between the database and the cache file.

## 3. Key Data Structures

The manager's intelligence is powered by three key attributes:

### 3.1. `self.cache`

This is the main in-memory cache, loaded from and saved to `summary_backup.json`.

*   **Structure**: `Dict[str, Dict[str, Any]]`
    *   The outer dictionary is keyed by the node's `label` (e.g., `"FUNCTION"`, `"CLASS_STRUCTURE"`).
    *   The inner dictionary is keyed by the node's unique identifier (its `id` for symbols or `path` for files/folders).
    *   The value is a dictionary containing the cached data, for example: `{"code_hash": "...", "code_analysis": "...", "summary": "..."}`.

### 3.2. `self.runtime_status`

This is a transient, in-memory dictionary that is created fresh for each run. It is the heart of the dependency-based staleness detection system.

*   **Structure**: `Dict[str, Dict[str, Any]]` (mirrors the structure of `self.cache`).
*   **Flags**: Each entry contains boolean flags:
    *   `visited`: Set to `True` if a node is processed in any way during the run. This is used by the `builder` mode to prune the cache of entries for nodes that no longer exist.
    *   `code_analysis_changed`: Set to `True` only when a `code_analysis` is truly regenerated by an LLM call. This flag is read by later passes to detect stale dependencies.
    *   `summary_changed`: Set to `True` only when a final `summary` is regenerated. This is also used for dependency tracking in hierarchical passes.

### 3.3. `self.started_with_empty_cache`

A simple boolean flag set during the `load()` method if `summary_backup.json` does not exist. This flag is critical for triggering the "cache healing" mechanism.

## 4. Core Logic and Methods

### `load()`

*   Called once at the beginning of a `RagGenerator` or `RagUpdater` run.
*   If `.cache/summary_backup.json` exists, it loads the JSON content into `self.cache`.
*   If the file does **not** exist, it sets `self.started_with_empty_cache = True` and proceeds with an empty cache.

### `save(mode: str, neo4j_mgr: Neo4jManager, is_intermediate: bool = False)`

This is the most critical method, implementing the **"Promote-on-Success"** strategy to ensure a good cache is never accidentally overwritten by a bad or incomplete run.

*   **Intermediate Saves**: If `is_intermediate=True`, the method performs a simple, direct write of the current in-memory `cache` to a temporary file (`summary_backup.json.tmp`). This is called by the orchestrator after each major pass to prevent data loss on failure, without touching the main cache file or its backups.

*   **Final Save**: If `is_intermediate=False`, it executes the final, multi-step promotion process:
    1.  **Pruning (Builder Mode)**: If the `mode` is `"builder"`, it first prunes the in-memory cache, keeping only the entries that were `visited` during the run.
    2.  **Write to Temp File**: It writes the final, pruned state of the in-memory cache to `summary_backup.json.tmp`.
    3.  **Promotion**: It then calls the internal `_promote_tmp_cache()` method, which orchestrates the sanity check and promotion.

### `_promote_tmp_cache()`

This private method contains the core safety logic for promoting the temporary cache to the official cache.

1.  **Sanity Check**: It compares the number of entries in the new `.tmp` file with the number in the current `summary_backup.json` (if it exists).
2.  **Check Failure**: If the new cache has fewer than 95% of the entries of the old one (and the old one was not trivially small), it assumes a failure. It logs a **critical error** and **aborts the promotion**. The `.tmp` file is left in place for manual inspection, and the existing good cache and its backups are left untouched.
3.  **Check Success**: If the sanity check passes, it calls `_rotate_backups()`.
4.  **Final Rename**: After the backups are rotated, it renames `summary_backup.json.tmp` to `summary_backup.json`, officially completing the promotion.

### `_rotate_backups()`

This helper method manages a 2-level rolling backup system:
*   `summary_backup.json.bak.2` is deleted.
*   `summary_backup.json.bak.1` is renamed to `summary_backup.json.bak.2`.
*   `summary_backup.json` is renamed to `summary_backup.json.bak.1`.

## 5. Command-Line Interface

The `summary_cache_manager.py` script can be run directly from the command line to perform manual cache operations.

*   **Path Discovery**: The script does not require a `--project-path`. It automatically discovers the project path by querying the `PROJECT` node in the Neo4j database.

### `backup` command

*   **Purpose**: Performs a full backup of all summaries from the Neo4j database into the cache file, overwriting the existing cache. This is useful for creating a complete, known-good cache file from the database state.
*   **Usage**: `python summary_cache_manager.py backup`
*   **Method**: Calls `backup_db_to_file()`.

### `restore` command

*   **Purpose**: Restores all summaries from the cache file back into the Neo4j database. This is useful for populating a new or empty database.
*   **Usage**: `python summary_cache_manager.py restore`
*   **Method**: Calls `restore_db_from_file()`.