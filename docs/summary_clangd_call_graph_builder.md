# Algorithm Summary: `clangd_call_graph_builder.py`

## 1. Role in the Pipeline

This script acts as a **library module** for the main `clangd_code_graph_builder.py` orchestrator. Its sole responsibility is to perform Pass 3 of the ingestion pipeline: identifying all function call relationships and generating the query to create them in Neo4j.

It provides the `ClangdCallGraphExtractor` class, which encapsulates this logic.

## 2. Core Logic

The fundamental challenge in building a call graph is that the `clangd` index provides call sites, but doesn't explicitly link them to the function that contains them (the caller). This module solves this by bridging the `clangd` data with function body spans extracted by `tree-sitter`.

### Algorithm

1.  **Data Ingestion**: The class is designed to take two inputs from the main orchestrator:
    *   The full content of the `clangd` index YAML file.
    *   A list of `FunctionSpan` objects, pre-generated by the `SpanExtractor`.

2.  **Robust Parsing**: It uses a two-pass parsing strategy on the YAML content to first build a complete dictionary of all `!Symbol` documents, and then process the `!References` documents. This ensures references are never discarded, regardless of their order in the file.

3.  **Span Matching**: It matches the `clangd` function symbols to the `tree-sitter` function spans using a composite key of `(function_name, file_uri, start_line, start_column)`. This enriches the `clangd` function symbols with a `body_location` property.

4.  **Call Relationship Extraction**: The script can extract call relationships using two different algorithms. The default is an optimized, spatially-indexed approach, while a slower, brute-force method is kept for reference.

    *   **Optimized Algorithm (`extract_call_relationships`)**:
        *   **Spatial Index Creation**: It first builds an in-memory "spatial index". This is a dictionary where keys are file URIs. The value for each file is a list of all function bodies contained in that file, sorted by their starting line number.
        *   **Optimized Lookup**: It then iterates through every symbol in the index. For each function call reference (`Kind: 12`), it performs a highly optimized lookup:
            *   It instantly retrieves the list of candidate functions by looking up the call's file URI in the spatial index.
            *   Because the list is sorted, it can efficiently find the containing function body for the call site.
        *   **Relation Recording**: Once the containing (caller) function is identified, it records a `(caller, callee)` `CallRelation` object. This avoids the expensive process of iterating through every known function for every call site.

    *   **Slow Algorithm (`extract_call_relationships_slow`)**:
        *   This is the original, brute-force implementation.
        *   It iterates through every symbol in the index, looking for function calls (references with `Kind: 12`).
        *   For each call site, it then iterates through **all** known functions that have a `body_location` to find which function body contains the call site.
        *   This `O(references * functions)` approach is correct but does not scale well for large codebases, which is why it was replaced by the optimized version.

## 3. Output

Once all call relations have been discovered, the `get_call_relation_ingest_query` method is called.

-   **Efficient Query Generation**: This method does **not** generate thousands of individual queries. Instead, it generates a single, highly performant, parameterized Cypher query that uses the `UNWIND` clause.
-   **Return Value**: It returns a tuple containing:
    1.  The Cypher query string.
    2.  A dictionary of parameters containing the list of all `(caller_id, callee_id)` pairs.

This output is then passed back to the main orchestrator, which executes the query to merge all `:CALLS` relationships into the graph in one efficient transaction.
